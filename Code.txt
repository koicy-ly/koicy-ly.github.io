// Please submit with C++17! It's best to use C++20 or higher version.
// By Koicy (https://koicy.ly)
// rbtree (i@koicy.ly)
// I've reached the end of my illusion.
constexpr bool _CONSOLE = false, _MULTI_TESTS = false;
constexpr char EFILE[] = "";
#include<algorithm>
#include<array>
#include<bitset>
#include<cassert>
#include<cmath>
#include<cstring>
#include<functional>
#include<list>
#include<map>
#include<memory>
#include<numeric>
#include<queue>
#include<random>
#include<set>
#include<stack>
#include<string>
#include<tuple>
#include<unordered_map>
#include<utility>
#include<vector>
#define FULL(arg) arg.begin(), arg.end()

// :\

constexpr unsigned long long BUF=2172179;using tp=long long;using namespace std;constexpr tp ZERO=0,ONE=1,INF32=-1u>>2,INF=-1ull>>2;using PTT=pair<tp,tp>;
#ifdef _LOCAL
#include"lib.h"
#else
#define NDEBUG true
namespace _IO{unsigned long long h=5;char ibuf[BUF],obuf[BUF];char*li,*ri,*lo=obuf,*ro=obuf+BUF,st[100],*tp=st;FILE*Istream=stdin,*Ostream=stdout;char GC(){if(_CONSOLE)return getchar();if(li==ri){li=ibuf;ri=li+fread(li,1,BUF,Istream);if(li==ri)return'\n';}return*li++;}void _flush(){fwrite(obuf,1,lo-obuf,Ostream);lo=obuf;}void PC(char ch){if(_CONSOLE)return(void)putchar(ch);if(lo==ro)_flush();*lo++=ch;}template<typename Type>void r_int(Type&x){bool neg=0;char ch=GC();while(ch<48||ch>57){neg^=ch==45;ch=GC();}for(x=0;ch>='0'&&ch<='9';ch=GC())x=x*10+(ch&15);if(neg)x=-x;}template<typename Type>void r_uint(Type&x){char ch=GC();while(ch<48||ch>57)ch=GC();for(x=0;ch>='0'&&ch<='9';ch=GC())x=x*10+(ch&15);}template<typename Type>void r_db(Type&x){bool neg=0;char ch=GC();while(ch<48||ch>57){neg^=ch==45;ch=GC();}for(x=0;ch>='0'&&ch<='9';ch=GC())x=x*10+(ch&15);if(ch=='.'){double p=1;for(ch=GC();ch>='0'&&ch<='9';ch=GC())x+=static_cast<Type>(p/=10)*(ch&15);}if(neg)x=-x;}template<typename Type>void w_uint(Type x){if(!x){PC('0');return;}while(x){*tp++=x%10;x/=10;}while(tp>st)PC(*--tp^48);}template<typename Type>void w_int(Type x){if(x<0){PC('-');while(x){*tp++=x%10;x/=10;}while(tp>st)PC(-*--tp^48);}else w_uint(x);}template<typename Type>void w_db(Type x){double l=floor(abs(x));std::string s;if(x<0){PC('-');x=-x;}x-=static_cast<Type>(l);if(!l)PC(48);while(l){s.push_back(static_cast<char>(l-floor(l/10)*10));l=floor(l/10);}for(auto i=s.rbegin();i!=s.rend();++i)PC(*i^48);PC(46);for(unsigned long long f=0;f<h;++f){x*=10;PC(static_cast<char>(floor(x-floor(x/10)*10)+48));}}struct IO{IO&operator>>(char&x){do{x=GC();}while(x==32||x==10||x==13);return*this;}IO&operator>>(std::string&x){char c;operator>>(c);x=c;for(c=GC();c!=32&&c!=10&&c!=13;c=GC())x.push_back(c);x.shrink_to_fit();return*this;}IO&operator>>(short&x){r_int(x);return*this;}IO&operator>>(signed&x){r_int(x);return*this;}IO&operator>>(long&x){r_int(x);return*this;}IO&operator>>(long long&x){r_int(x);return*this;}IO&operator>>(unsigned short&x){r_uint(x);return*this;}IO&operator>>(unsigned&x){r_uint(x);return*this;}IO&operator>>(unsigned long&x){r_uint(x);return*this;}IO&operator>>(unsigned long long&x){r_uint(x);return*this;}IO&operator>>(float&x){r_db(x);return*this;}IO&operator>>(double&x){r_db(x);return*this;}template<typename Ty1,typename Ty2>IO&operator>>(pair<Ty1,Ty2>&x){return*this>>x.first>>x.second;}IO&operator<<(short x){w_int(x);return*this;}IO&operator<<(signed x){w_int(x);return*this;}IO&operator<<(long x){w_int(x);return*this;}IO&operator<<(long long x){w_int(x);return*this;}IO&operator<<(unsigned short x){w_uint(x);return*this;}IO&operator<<(unsigned x){w_uint(x);return*this;}IO&operator<<(unsigned long x){w_uint(x);return*this;}IO&operator<<(unsigned long long x){w_uint(x);return*this;}IO&operator<<(char x){PC(x);return*this;}IO&operator<<(const std::string&x){for(auto&i:x)PC(i);return*this;}IO&operator<<(float x){w_db(x);return*this;}IO&operator<<(double x){w_db(x);return*this;}void flush(){_flush();}void precision(unsigned long long p){h=p;}std::string getline(){char c;std::string x;operator>>(c);x=c;for(c=GC();c!=10&&c!=13;c=GC())x.push_back(c);x.shrink_to_fit();return x;}template<typename Pointer>void rar(Pointer s,Pointer t){while(s!=t)operator>>(*s++);}IO(){if(strlen(EFILE)){Istream=fopen((EFILE+string(".in")).c_str(),"r");Ostream=fopen((EFILE+string(".out")).c_str(),"w");}}~IO(){_flush();}}bin;}using _IO::bin;
namespace lib{
#ifdef __SIZEOF_INT128__
struct Barrett{typedef unsigned long long ull;typedef __uint128_t LL;ull m,B;Barrett()=default;Barrett(ull m):m(m),B((LL(1)<<64)/m){}friend ull operator%(ull a,const Barrett&mod){ull r=a-mod.m*(LL(mod.B)*a>>64);return r>=mod.m?r-mod.m:r;}};
#else
struct Barrett{using ull = unsigned long long;ull m;Barrett()=default;Barrett(ull m):m(m){}friend ull operator%(ull a,const Barrett&mod){return a%mod.m;}};
#endif
template<typename Ty>Ty gcd(Ty x,Ty y){while(y^=x^=y^=x%=y);return x;}
class Block_Forest_Builder{using Ty=long long;vector<vector<Ty>>G,T;vector<Ty>dfn,low,stk;size_t cnt;void Tarjan(Ty u){low[u]=dfn[u]=cnt++;stk.push_back(u);for(auto&v:G[u]){if(!dfn[v]){Tarjan(v);low[u]=min(low[u],low[v]);if(low[v]==dfn[u]){T.push_back(vector<Ty>());for(long long x=-1;x!=v;stk.pop_back()){x=stk.back();T[T.size()-1].push_back(x);T[x].push_back(T.size()-1);}T[T.size()-1].push_back(u);T[u].push_back(T.size()-1);}}else low[u]=min(low[u],dfn[v]);}}public:Block_Forest_Builder():cnt(0){};vector<vector<Ty>>&operator()(vector<vector<Ty>>&g){G.swap(g);cnt=0;low=dfn=vector<Ty>(G.size(),0);T.resize(G.size());for(size_t i=0;i<G.size();++i){if(!dfn[i]){Tarjan(i);stk.clear();}}G.swap(g);return T;}}Block_Forest;
tp BSGS(tp a,tp b,tp p,tp c=1){tp t=static_cast<tp>(ceil(sqrt(p))),val=1;map<tp,tp>m;b=b%p;for(tp i=0;i<t;++i){m[b*val%p]=i;val=val*a%p;}a=val;if(!a)return b?-1:1;for(tp i=1,val=c;i<=t;++i){val=val*a%p;if(m.count(val))return i*t-m[val];}return-1;}
struct Complex{double r,i;Complex()=default;Complex(double x,double y):r(x),i(y){}Complex operator+(Complex const&b)const{return Complex(r+b.r,i+b.i);}Complex operator-(Complex const&b)const{return Complex(r-b.r,i-b.i);}Complex operator*(Complex const&b)const{return Complex(r*b.r-i*b.i,r*b.i+i*b.r);}Complex operator/(Complex const&b)const{double t=b.r*b.r+b.i*b.i;return Complex((r*b.r+i*b.i)/t,(i*b.r-r*b.i)/t);}Complex operator+=(Complex const&b){return*this=*this+b;}Complex operator-=(Complex const&b){return*this=*this-b;}Complex operator*=(Complex const&b){return*this=*this*b;}Complex operator/=(Complex const&b){return*this=*this/b;}};
vector<long long>dijkstra(vector<vector<pair<long long,long long>>>e,long long s){constexpr long long INF=-1ull>>2;priority_queue<pair<long long,long long>,vector<pair<long long,long long>>,greater<pair<long long,long long>>>pq;vector<bool>vis(e.size(),false);vector<long long>dist(e.size(),INF);dist[s]=0;for(pq.emplace(0,s);pq.size();){long long loc=pq.top().second;pq.pop();if(!vis[loc]){vis[loc]=true;for(auto&i:e[loc]){if(dist[i.first]>dist[loc]+i.second){dist[i.first]=dist[loc]+i.second;if(!vis[i.first])pq.emplace(dist[i.first],i.first);}}}}for(auto&i:dist){if(i==INF)i=-1;}return dist;}
struct DSU{vector<size_t>f,s;vector<pair<size_t,size_t>>hs,hf;DSU(size_t t){f.resize(t);s=vector<size_t>(t,1);iota(f.begin(),f.end(),0);}size_t root(size_t x){return f[x]==x?x:root(f[x]);}void link(size_t u,size_t v){u=root(u);v=root(v);if(s[u]>s[v])swap(u,v);hs.emplace_back(v,s[v]);hf.emplace_back(u,f[u]);if(u==v)return;f[u]=v;s[v]+=s[u];}size_t size(size_t x){return s[root(x)];}void undo(){f[hf.back().first]=hf.back().second;s[hs.back().first]=hs.back().second;hs.pop_back();hf.pop_back();}};
tp exBSGS(tp a,tp b,tp p){a=a%p;b=b%p;if(b==1||p==1)return 0;tp t=0,d,c=1;while((d=gcd(a,p))!=1){if(b%d)return-1;++t;b/=d;p/=d;c=(a/d*c)%p;if(c==b)return t;}tp ans=BSGS(a,b,p,c);if(ans==-1)return-1;return ans+t;}
template<typename Ty>void exgcd(Ty a,Ty b,Ty&x,Ty&y){if(b){exgcd(b,a%b,y,x);y-=a/b*x;}else{x=1;y=0;}}
void FFT(vector<Complex>&f,tp n,tp type){double pi2=acos(-1)*2;for(tp i=0,k=0;i<n;++i){if(i<k)swap(f[i],f[k]);for(tp j=n/2;(k^=j)<j;j/=2);}for(tp p=2;p<=n;p*=2){tp m=p/2;Complex w(cos(pi2/p),type*sin(pi2/p));for(tp k=0;k<n;k+=p){Complex g(1,0);for(tp l=k;l<k+m;++l){Complex t=g*f[m+l];f[m+l]=f[l]-t;f[l]+=t;g*=w;}}}if(type==1)return;for(tp i=0;i<n;++i)f[i].r/=n;for(tp i=0;i<n;++i)f[i].i/=n;}
template<typename Ty>Ty inverse(Ty a,Ty mod){Ty x,y;exgcd(a,mod,x,y);return x<0?x+mod:x;}
template<typename S,S(*op)(S,S),S(*e)()>class Light_Segtree{size_t length,size,log;vector<S>data;void update(size_t k){data[k]=op(data[2*k],data[2*k+1]);}public:Light_Segtree():Light_Segtree(0){}Light_Segtree(size_t n):Light_Segtree(std::vector<S>(n,e())){}Light_Segtree(const std::vector<S>&v):length(v.size()),size(1),log(63){while(size<length)size*=2;size_t x=size&-size;if(x&0x00000000FFFFFFFF)log-=32;if(x&0x0000FFFF0000FFFF)log-=16;if(x&0x00FF00FF00FF00FF)log-=8;if(x&0x0F0F0F0F0F0F0F0F)log-=4;if(x&0x3333333333333333)log-=2;if(x&0x5555555555555555)log-=1;data=std::vector<S>(2*size,e());for(size_t i=0;i<length;++i)data[size+i]=v[i];for(size_t i=size-1;i>=1;--i)update(i);}void set(size_t p,S x){data[p+=size]=x;for(size_t i=1;i<=log;++i)update(p>>i);}S get(size_t p){return data[p+size];}S product(size_t l,size_t r){if(r<l)return e();l+=size;r+=size+1;S sml=e(),smr=e();while(l<r){if(l&1)sml=op(sml,data[l++]);if(r&1)smr=op(data[--r],smr);l/=2;r/=2;}return op(sml,smr);}S all_product(){return data[1];}template<bool(*g)(S)>size_t max_right(size_t l){return max_right(l,[](S x){return g(x);});}template<typename G>size_t max_right(size_t l,G g){if(l==length)return length;l+=size;S sm=e();do{while(l%2==0)l/=2;if(!g(op(sm,data[l]))){while(l<size){l*=2;if(g(op(sm,data[l])))sm=op(sm,data[l++]);}return l-size;}sm=op(sm,data[l++]);}while((l&-l)!=l);return length;}template<bool(*g)(S)>size_t min_left(size_t r){return min_left(r,[](S x){return g(x);});}template<typename G>size_t min_left(size_t r,G g){if(r==0)return 0;r+=size;S sm=e();do{r--;while(r>1&&(r%2))r/=2;if(!g(op(data[r],sm))){while(r<size){r=2*r+1;if(g(op(data[r],sm)))sm=op(data[r--],sm);}return r+1-size;}sm=op(data[r],sm);}while((r&-r)!=r);return 0;}};
template<unsigned long long Mod>struct Matrix:vector<vector<long long>>{private:using type=unsigned long long;public:Matrix()=default;Matrix(type n,type m){resize(n);for(type i=0;i<n;++i){for(type j=0;j<m;++j)operator[](i).push_back(0);}}Matrix operator*(const Matrix&b){Matrix c(size(),b[0].size());for(type i=0;i<size();++i){for(type j=0;j<b[0].size();++j){for(type k=0;k<b.size();++k)c[i][j]=(c[i][j]+operator[](i)[k]*b[k][j])%Mod;}}return c;}Matrix operator+(const Matrix&b){Matrix c(size(),b[0].size());for(type i=0;i<size();++i){for(type j=0;j<b[0].size();++j)c[i][j]=operator[](i)[j]+b[i][j];}return c;}Matrix operator-(const Matrix&b){Matrix c(size(),b[0].size());for(type i=0;i<size();++i){for(type j=0;j<b[0].size();++j)c[i][j]=operator[](i)[j]-b[i][j];}return c;}Matrix qpow(unsigned long long p){Matrix tar(size(),size()),self=*this;for(type i=0;i<size();++i)tar[i][i]=1;while(p){if(p&1)tar*=self;self*=self;p/=2;}return tar;}Matrix operator*=(const Matrix&b){return*this=*this*b;}Matrix operator+=(const Matrix&b){return*this=*this+b;}Matrix operator-=(const Matrix&b){return*this=*this-b;}};
class Max_Flow_Builder{using tp=long long;static constexpr tp INF=-1ull>>2;struct edge{tp to,flow,next;edge(tp to,tp flow,tp next):to(to),flow(flow),next(next){}};vector<vector<edge>>a;vector<tp>h,cnt,que,e;vector<vector<tp>>lis;vector<list<tp>::iterator>iter;vector<list<tp>>dlist;tp hst,nowh;void addEdge(tp u,tp v,tp f){a[u].emplace_back(v,f,a[v].size());a[v].emplace_back(u,0,a[u].size()-1);}void relabel(tp n,tp t){h.assign(n,n);h[t]=0;cnt.assign(n,0);que.clear();que.resize(n+1);tp qh=0,qt=0;for(que[qt++]=t;qh<qt;){tp u=que[qh++],het=h[u]+1;for(auto p=a[u].begin();p!=a[u].end();++p){if(h[p->to]==n&&a[p->to][p->next].flow>0){cnt[h[p->to]=het]++;que[qt++]=p->to;}}}for(tp i=0;i<=n;++i){lis[i].clear();dlist[i].clear();}for(tp u=0;u<n;++u){if(h[u]<n){iter[u]=dlist[h[u]].insert(dlist[h[u]].begin(),u);if(e[u]>0)lis[h[u]].push_back(u);}}hst=(nowh=h[que[qt-1]]);}void push(tp u,edge&ed){tp v=ed.to;tp df=min(e[u],ed.flow);ed.flow-=df;a[v][ed.next].flow+=df;e[u]-=df;e[v]+=df;if(0<e[v]&&e[v]<=df)lis[h[v]].push_back(v);}void push(tp n,tp u){tp nh=n;for(auto p=a[u].begin();p!=a[u].end();++p){if(p->flow>0){if(h[u]==h[p->to]+1){push(u,*p);if(e[u]==0)return;}else nh=min(nh,h[p->to]+1);}}tp het=h[u];if(cnt[het]==1){for(tp i=het;i<=hst;++i){for(auto it=dlist[i].begin();it!=dlist[i].end();++it){cnt[h[*it]]--;h[*it]=n;}dlist[i].clear();}hst=het-1;}else{cnt[het]--;iter[u]=dlist[het].erase(iter[u]);h[u]=nh;if(nh==n)return;cnt[nh]++;iter[u]=dlist[nh].insert(dlist[nh].begin(),u);hst=max(hst,nowh=nh);lis[nh].push_back(u);}}tp hlpp(tp n,tp s,tp t){if(s==t)return 0;nowh=0;hst=0;h.assign(n+1,0);h[s]=n+1;iter.resize(n+1);for(tp i=0;i<=n;++i)if(i!=s)iter[i]=dlist[h[i]].insert(dlist[h[i]].begin(),i);cnt.assign(n+1,0);cnt[0]=n;e.assign(n+1,0);e[s]=INF;e[t]=-INF;for(size_t i=0;i<a[s].size();++i)push(s,a[s][i]);relabel(n+1,t);for(tp u;nowh>=0;){if(lis[nowh].empty()){nowh--;continue;}u=lis[nowh].back();lis[nowh].pop_back();push(n,u);}return e[t]+INF;}public:Max_Flow_Builder():hst(0),nowh(0){};tp operator()(vector<vector<pair<tp,tp>>>g,tp s,tp t){tp n=g.size();hst=nowh=0;a.clear();a.resize(n+1);lis.clear();lis.resize(n+2);dlist.clear();dlist.resize(n+2);for(size_t i=0;i<g.size();++i){for(auto&j:g[i])addEdge(i,j.first,j.second);}return hlpp(n,s,t);}}Max_Flow;
class MCMF_Builder{using tp=long long;static constexpr tp INF=-1ull>>2;struct edge{tp to,cap,coc,cost;edge(tp to,tp cap,tp coc,tp cost):to(to),cap(cap),coc(coc),cost(cost){}};vector<vector<edge>>g;vector<bool>inq;vector<tp>d,pre1,pre2,incf;void add(tp u,tp v,tp w,tp f){g[u].emplace_back(v,w,g[v].size(),f);g[v].emplace_back(u,0,g[u].size()-1,-f);}bool spfa(tp s,tp t){d=vector<tp>(g.size(),INF);inq=vector<bool>(g.size(),false);queue<tp>q;q.push(s);d[s]=0;inq[s]=true;incf[s]=INF;while(!q.empty()){tp now=q.front();inq[now]=false;q.pop();for(size_t i=0;i<g[now].size();++i){edge e=g[now][i];if(e.cap>0&&e.cost+d[now]<d[e.to]){d[e.to]=d[now]+e.cost;incf[e.to]=min(incf[now],e.cap);pre1[e.to]=now;pre2[e.to]=i;if(!inq[e.to]){inq[e.to]=true;q.push(e.to);}}}}return d[t]!=INF;}public:MCMF_Builder()=default;pair<tp,tp>operator()(vector<vector<tuple<tp,tp,tp>>>e,tp s,tp t){tp maxf=0,ans=0;g.clear();g.resize(e.size());pre1=pre2=incf=vector<tp>(e.size(),0);for(size_t i=0;i<e.size();++i){for(auto&j:e[i])add(i,get<0>(j),get<1>(j),get<2>(j));}while(spfa(s,t)){tp x=t;while(x!=s){tp y=pre1[x],i=pre2[x];g[y][i].cap-=incf[t];g[x][g[y][i].coc].cap+=incf[t];x=y;}maxf+=incf[t];ans+=d[t]*incf[t];}return make_pair(maxf,ans);}}MCMF;
class Miller_Rabin_Builder{mt19937_64 rnd;long long smul(long long x,long long y,long long mod){long long tar=0;while(y){if(y&1)tar=(tar+x)%mod;x=x*2%mod;y/=2;}return tar;}long long qpow(long long x,long long y,long long mod){long long tar=1;while(y){if(y&1)tar=tar*x%mod;x=x*x%mod;y/=2;}return tar;}public:Miller_Rabin_Builder(long long seed){rnd=mt19937_64(seed);}bool operator()(long long p,unsigned long long t=10){if(p<=3)return p>=2;int r=0;long long d=p-1;while(d%2==0){++r;d/=2;}while(t--){long long a=rand()%(p-2)+2,x=qpow(a,d,p);if(x==1||x==p-1)continue;for(int i=-1;i!=r;++i){x=smul(x,x,p);if(x==p-1)break;}if(x!=p-1)return false;}return true;}}Miller_Rabin(reinterpret_cast<unsigned long long>(new char));
template<long long mod>class Mint{using type=long long;type mad(type x,type y){return x+y>=mod?x+y-mod:x+y;}type mid(type x,type y){return x-y<0?x-y+mod:x-y;}type pow(type x,type y){type tar=1;while(y){if(y&1)tar=tar*x%mod;x=x*x%mod;y/=2;}return tar;}public:type x;Mint()=default;Mint(type x):x(x%mod){}Mint inv(Mint x){return pow(x,mod-2);}Mint operator+(Mint y){return mad(x,y.x);}Mint operator-(Mint y){return mid(x,y.x);}Mint operator*(Mint y){return x*y.x%mod;}Mint operator/(Mint y){return x*inv(y.x)%mod;}Mint operator^(Mint y){return pow(x,y.x);}operator type(){return x;}Mint operator+=(Mint y){return x=mad(x,y.x);}Mint operator-=(Mint y){return x=mid(x,y.x);}Mint operator*=(Mint y){return x=x*y.x%mod;}Mint operator/=(Mint y){return x=x*inv(y.x)%mod;}Mint operator^=(Mint y){return x=pow(x,y.x);}};
long long qpow(long long x,long long y,long long mod){long long tar=1;while(y){if(y&1)tar=tar*x%mod;x=x*x%mod;y/=2;}return tar;}
class Random{mt19937_64 rd;public:Random(unsigned long long seed){rd=mt19937_64(seed);}long long operator()(long long l,long long r){return l+rd()%(r-l+1);}}rnd(reinterpret_cast<unsigned long long>(new char));
template<typename S,S(*op)(S,S),S(*e)(),typename F,S(*mapping)(F,S),F(*composition)(F,F),F(*id)()>class Segtree{size_t length,size,log;vector<S>data;vector<F>tag;void update(size_t k){data[k]=op(data[2*k],data[2*k+1]);}void all_apply(size_t k,F f){data[k]=mapping(f,data[k]);if(k<size)tag[k]=composition(f,tag[k]);}void push(size_t k){all_apply(2*k,tag[k]);all_apply(2*k+1,tag[k]);tag[k]=id();}public:Segtree():Segtree(0){}Segtree(size_t n):Segtree(std::vector<S>(n,e())){}Segtree(const std::vector<S>&v):length(v.size()),size(1),log(63){while(size<length)size*=2;size_t x=size&-size;if(x&0x00000000FFFFFFFF)log-=32;if(x&0x0000FFFF0000FFFF)log-=16;if(x&0x00FF00FF00FF00FF)log-=8;if(x&0x0F0F0F0F0F0F0F0F)log-=4;if(x&0x3333333333333333)log-=2;if(x&0x5555555555555555)log-=1;data=std::vector<S>(2*size,e());tag=std::vector<F>(size,id());for(size_t i=0;i<length;++i)data[size+i]=v[i];for(size_t i=size-1;i>=1;--i)update(i);}void set(size_t p,S x){p+=size;for(size_t i=log;i>=1;--i)push(p>>i);data[p]=x;for(size_t i=1;i<=log;++i)update(p>>i);}S get(size_t p){p+=size;for(size_t i=log;i>=1;--i)push(p>>i);return data[p];}S product(size_t l,size_t r){if(r<l)return e();l+=size;r+=size+1;for(size_t i=log;i>=1;--i){if(((l>>i)<<i)!=l)push(l>>i);if(((r>>i)<<i)!=r)push((r-1)>>i);}S sml=e(),smr=e();while(l<r){if(l&1)sml=op(sml,data[l++]);if(r&1)smr=op(data[--r],smr);l/=2;r/=2;}return op(sml,smr);}S all_product(){return data[1];}void apply(size_t p,F f){p+=size;for(size_t i=log;i>=1;--i)push(p>>i);data[p]=mapping(f,data[p]);for(size_t i=1;i<=log;++i)update(p>>i);}void apply(size_t l,size_t r,F f){if(r<l)return;l+=size;r+=size+1;for(size_t i=log;i>=1;--i){if(((l>>i)<<i)!=l)push(l>>i);if(((r>>i)<<i)!=r)push((r-1)>>i);}size_t _l=l,_r=r;while(l<r){if(l&1)all_apply(l++,f);if(r&1)all_apply(--r,f);l/=2;r/=2;}l=_l;r=_r;for(size_t i=1;i<=log;++i){if(((l>>i)<<i)!=l)update(l>>i);if(((r>>i)<<i)!=r)update((r-1)>>i);}}template<bool(*g)(S)>size_t max_right(size_t l){return max_right(l,[](S x){return g(x);});}template<typename G>size_t max_right(size_t l,G g){if(l==length)return length;l+=size;for(size_t i=log;i>=1;--i)push(l>>i);S sm=e();do{while(l%2==0)l/=2;if(!g(op(sm,data[l]))){while(l<size){push(l);l*=2;if(g(op(sm,data[l])))sm=op(sm,data[l++]);}return l-size;}sm=op(sm,data[l++]);}while((l&-l)!=l);return length;}template<bool(*g)(S)>size_t min_left(size_t r){return min_left(r,[](S x){return g(x);});}template<typename G>size_t min_left(size_t r,G g){if(r==0)return 0;r+=size;for(size_t i=log;i>=1;--i)push((r-1)>>i);S sm=e();do{r--;while(r>1&&(r%2))r/=2;if(!g(op(data[r],sm))){while(r<size){push(r);r=2*r+1;if(g(op(data[r],sm)))sm=op(data[r--],sm);}return r+1-size;}sm=op(data[r],sm);}while((r&-r)!=r);return 0;}};
long long smul(long long x,long long y,long long mod){long long tar=0;while(y){if(y&1)tar=(tar+x)%mod;x=x*2%mod;y/=2;}return tar;}
vector<long long>SPFA(vector<vector<pair<long long,long long>>>e,long long s){constexpr tp INF=-1ull>>2;vector<bool>inq(e.size(),false);vector<long long>dist(e.size(),INF);vector<size_t>cnt(e.size(),0);list<long long>q;inq[s]=true;dist[s]=0;for(q.push_back(s);q.size();q.pop_front()){inq[q.front()]=false;for(auto&i:e[q.front()]){if(dist[i.first]>dist[q.front()]+i.second){dist[i.first]=dist[q.front()]+i.second;if(!inq[i.first]){inq[i.first]=true;q.push_back(i.first);if(++cnt[i.first]>e.size())return vector<long long>();}}}}for(auto&i:dist){if(i==INF)i=-1;}return dist;}
template<typename Type,typename Operation>class ST{vector<unsigned long long>lg;vector<vector<Type>>t;size_t n;Operation Calc;public:ST()=default;ST(const vector<Type>&arr){n=arr.size();lg=vector<unsigned long long>(n+1,0);for(size_t i=2;i<=n;++i)lg[i]=lg[i/2]+1;t=vector<vector<Type>>(lg[n]+1,vector<Type>(n));t[0]=arr;for(size_t i=0;i<lg[n];++i){for(size_t j=0;j<=n-(2ll<<i);++j)t[i+1][j]=Calc(t[i][j],t[i][j+(1ll<<i)]);}}Type operator()(size_t l,size_t r){tp k=lg[r-l+1];return Calc(t[k][l],t[k][r-(1ll<<k)+1]);}};
template<typename Typex>class Tree{double _Alpha;struct TNode;using iterator=TNode*;using type=unsigned long long;struct TNode{bool exist;Typex _Value;iterator LC,RC;type size,cover;TNode()=default;TNode(const Typex&_Key):_Value(_Key){exist=size=cover=1;}void _ReCalc(){size=LC->size+RC->size+exist;cover=LC->cover+RC->cover+1;}}*null,*root;iterator _NewNode(const Typex&_Value){iterator p=new TNode(_Value);p->LC=p->RC=null;return p;}void _Travel(iterator p,vector<iterator>&x){if(p==null)return;_Travel(p->LC,x);if(p->exist){x.push_back(p);_Travel(p->RC,x);}else{_Travel(p->RC,x);delete p;p=null;}}iterator _Divide(vector<iterator>&x,type l,type r){if(l<r){type mid=(l+r)/2;iterator p=x[mid];p->LC=_Divide(x,l,mid);p->RC=_Divide(x,mid+1,r);p->_ReCalc();return p;}else return null;}void _Rebuild(iterator&p){static vector<iterator>x;x.clear();_Travel(p,x);p=_Divide(x,0,x.size());}iterator*_Insert(iterator&p,const Typex&_Value){if(p==null){p=_NewNode(_Value);return&null;}++p->size;++p->cover;iterator*res=_Insert((_Value<p->_Value||!(p->_Value<_Value)?p->LC:p->RC),_Value);if((p->LC->cover>p->cover*_Alpha)||(p->RC->cover>p->cover*_Alpha))return&p;return res;}void _Remove(iterator&p,type k){--p->size;type offset=p->LC->size+p->exist;if(p->exist&&offset==k)p->exist=0;else k>offset?_Remove(p->RC,k-offset):_Remove(p->LC,k);}public:Tree(double Alpha):_Alpha(Alpha){null=new TNode;null->LC=null->RC=null;null->cover=null->size=null->exist=0;root=null;}void insert(const Typex&_Value){iterator*res=_Insert(root,_Value);if(*res!=null)_Rebuild(*res);}type size(){return root->size;}type order_of_key(const Typex&_Value){iterator now=root;type sum=1;while(now!=null){if(_Value<now->_Value||!(now->_Value<_Value))now=now->LC;else{sum+=now->LC->size+now->exist;now=now->RC;}}return sum;}const Typex&find_by_order(type _Value){iterator now=root;while(now!=null){if(now->LC->size+1==_Value&&now->exist)return now->_Value;if(now->LC->size>=_Value)now=now->LC;else{_Value-=now->LC->size+now->exist;now=now->RC;}}return Typex();}void erase(const Typex&k){_Remove(root,order_of_key(k));if(root->size<root->cover*_Alpha)_Rebuild(root);}};
}
#endif
void STRUGGLING(unsigned);void MIST();signed main(signed argc,char*argv[]){unsigned t=0,_t=1;if(_MULTI_TESTS)bin >> _t;MIST();while(t<_t)STRUGGLING(++t);return 0;}
#ifdef _DEBUG
template<typename _Type>void _dbg(const _Type&_cur){bin<<_cur<<"] <<:\n";bin.flush();}template<typename _Type,typename..._Other>void _dbg(const _Type&_cur,const _Other&..._other){bin<<_cur<<", ";_dbg(_other...);}
#else
#define dbg(...)
#define dputs(...)
#endif

// :/

void STRUGGLING([[maybe_unused]] unsigned TEST_NUMBER) {
}

void MIST() {
}

//*/
